# 2/6(일) 15:14
- ./push_swap 2 1 3 6 5 8 수행시 같은 피벗값으로 무한반복됨...
- 종료 로직에 문제?

# 2/6(dlf) 19:34
- input.c, main.c에 입출력 코드를 덧붙였다. "숫자열" 숫자의 연속이 들어와도 모두 파싱가능.

# 2/6(일) 21:24
- A_to_B, B_to_A함수에서 size만큼 반복문을 돌릴 때
 size자체를 감소시키며 루프를 돌리게 해서 재귀의 파라미터에 감소된 size가 들어가
 서 문제를 발생시켰다. 고쳤다.

- A_to_B함수가 자기자신을 재귀적으로 끝까지 부르는데 성공함.
 다만 함수스택을 빠져나오면서 B_to_A를 수행할때 문제가 있음.

- A는 뭉텅이단위로 B에 피벗이상의 값을 옮기는데
B는 뭉텅이 단위를 다시 정렬해서 A로 보내야하는데 이게 안되고있는 상황..

# 2/7(월) 17:24

- B_to_A에서는 A_to_B와는 다르게 오름차순으로 정렬해야 한다.
 그래야 pA를 할때 역순으로 쌓여서 내림차순으로 정렬되기 때문이다.
=> 이게 되네....?

- 이제 사용한 명령어를 리스트에 담는 작업을 해보자.

# 2/7(월) 17:43
libft의 리스트구조를 이용하여 명령어 리스트를 담는 작업을 완료했다.
./push_swap 2 1 3 6 5 8 수행시
현재 19개의 명령어가 소비됨.

리스트관련..
- 다만 리스트를 free할때 문제가 발생한다. 흠...
- 리스트를 단축하는 로직을 넣어보자.

알고리즘관련..
- A_to_B, B_to_A함수의 종료조건은 원소가 1개가 나올때까지이다.
 이 종료조건을 원소 3개이하까지로 확장해보자.
- 또한 원소3개이하가 아니더라도, 이미 정렬이 완성되어있다면 종료하는 로직도 추가한다.

입출력..
- 숫자가 아닌 실행인자값이 들어왔을때 프로그램을 종료하고 ERROR를 출력한다.

# 2/7(월) 17:52
./push_swap 2 1 3 6 5 8 수행시
	이미 정렬되었는지 체크하는 로직 추가 => 17

# 2/7(월) 18:36
현재 종료조건 함수를 작성하고 있는데 생각보다 큰 문제발생!
3개이하의 원소가 남았을때 정렬해주는 함수.
일단 A를 정렬하는지 B를 정렬하는지 알아야됨...

# 2/8(화) 14:02

3개이하 종료함수를 어떻게 만들지 고민중.
- A를 종료하는지 B를 종료하는지 구분하기 위해 각각 함수를 만들거나 이를 구분하는
	인자를 넣어서 해결가능
- 단, 명령어를 수행할때 opcode를 추가할 방법을 모색해야함
